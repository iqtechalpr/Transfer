package com.ag.transfer.test

import android.accessibilityservice.AccessibilityService
import android.accessibilityservice.GestureDescription
import android.accessibilityservice.GestureDescription.StrokeDescription
import android.content.Intent
import android.graphics.Path
import android.graphics.Rect
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityNodeInfo
import android.widget.Toast
import com.google.gson.Gson
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory


class AccessService : AccessibilityService() {

//    private var nodeInfo: AccessibilityNodeInfo? = null

    //private var isChild0 = false
    private var isChildPrint = false
    private val handler = Handler(Looper.getMainLooper())
    private var isStateChanged = false
    var isUseState = false
    var password = ""

    //val NOTIFICATION_ID = 1
    private val cmds: ArrayList<CmdModel> = ArrayList()
    private var index = 0
    private var child: ChildModel? = null
    private var nodeFucus: AccessibilityNodeInfo? = null
    private var idFucus = ""

    override fun onCreate() {
        super.onCreate()
//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
//            startNotification()
//        }
        println("Access service start")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        if (intent == null || intent.action == null) {
            return START_STICKY
        }
        when (intent.action) {
            "true" -> {
                val cmds = intent.getStringExtra("cmd").toString()
                val cmd = cmds.split(",")
                isChildPrint = false
                withdrawTrue(cmd[0], cmd[1], cmd[2])
            }
            "tap" -> {
                val cmd = intent.getStringExtra("cmd")
                var gson = Gson()
                var cmds = gson.fromJson(cmd, TapModel::class.java)
                tap(cmds.x, cmds.y, cmds.duration)
            }
            "childs" -> {
                isChildPrint = true
                getChild()
            }
            "text" -> {
                val cmd = intent.getStringExtra("cmd")
                enterText(cmd.toString())
            }
            "action" -> {
                val cmd = intent.getStringExtra("cmd")
                performAction(cmd.toString())
            }
//            "adb" -> {
//                var cmd = intent.getStringExtra("cmd")
//                var out = Adb.sendCommand(cmd.toString())
//                println("adb: " + out)
//                Toast.makeText(this, out, Toast.LENGTH_SHORT).show()
//            }
            "test" -> {
                sendTestData()
            }
        }
        return START_STICKY
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        val intType = event?.eventType
        if (intType == 32) {
            println("32 = TYPE_WINDOW_STATE_CHANGED")
            if (!isStateChanged) {
                isStateChanged = true
                if (!isUseState) return
                handler.postDelayed(runnable, 500)
            } else {
                if (!isUseState) return
                handler.removeCallbacks(runnable)
                handler.removeCallbacksAndMessages(null)
                handler.postDelayed(runnable, 500)
            }
        }
    }

    val runnable = object : Runnable {
        override fun run() {
            //nodeInfo = rootInActiveWindow
            println("StateChanged:" + index.toString())
            isStateChanged = false
            isUseState = false
            cmdProcess()
        }
    }

    private fun withdrawTrue(password: String, account: String, amount: String) {
        println(account + "," + amount.toString())
        this.password = password
        cmds.clear()
        var i = 0
        cmds.add(CmdModel(i++, "action", "HOME", "", false, 400))
        cmds.add(CmdModel(i++, "tap", "", "TrueMoney", true, 500))
        cmds.add(CmdModel(i++, "password", "th.co.truemoney.wallet:id/sliding_btnTextTransfer", "", true, 500))

        cmds.add(CmdModel(i++, "tap", "th.co.truemoney.wallet:id/edt_ref", "", true, 500))
        cmds.add(CmdModel(i++, "tap", "th.co.truemoney.wallet:id/common_edt", "", true, 200))
        cmds.add(CmdModel(i++, "text", "", account, false, 200))
        cmds.add(CmdModel(i++, "action", "BACK", "", false, 200))
        cmds.add(CmdModel(i++, "action", "BACK", "", false, 500))
        cmds.add(CmdModel(i++, "tap2", "th.co.truemoney.wallet:id/editTextAmount", "th.co.truemoney.wallet:id/editTextAmount", true, 200))
//        cmds.add(CmdModel(i++, "tap", "th.co.truemoney.wallet:id/editTextAmount", "", false, 200))
        cmds.add(CmdModel(i++, "text2", "", amount, false, 200))
        cmds.add(CmdModel(i++, "action", "BACK", "", false, 200))
        cmds.add(CmdModel(i++, "tap", "th.co.truemoney.wallet:id/btnTransferOrLogin", "", false, 500))

        index = 0
        cmdProcess()
    }

    private fun cmdProcess() {
        if (cmds.size == index) {
            println("finish")
            return
        }
        val cmd: CmdModel = cmds[index]
        println(cmd)
        if (cmd.cmd == "tap2") idFucus = cmd.text
        else  idFucus = ""
        if (cmd.isFindChild) getChild()

        if (cmd.id == "") findChildByText(cmd.text)
        else findChildById(cmd.id)
        println(child)
//        if (child == null) {
//            println("child null at: $index")
//            return
//        }
        if (cmd.cmd == "tap") {
            var x = child!!.x
            var y = child!!.y
            if (index == 1 && Var.isMainWidget) {
                x -= 50
                y -= 50
            }
            println("${x}, $y")
            tap(x.toFloat(), y.toFloat(), 100)
        } else if (cmd.cmd == "tap2") {

            tap(child!!.x.toFloat(), child!!.y.toFloat(), 100)
        } else if (cmd.cmd == "password") {
            if (child == null) {
                enterText(password)
                Thread.sleep(200)
            } else {
                tap(child!!.x.toFloat(), child!!.y.toFloat(), 100)
            }
        } else if (cmd.cmd == "text") {
//
//            if (index == 9) {
//                println("index == 9")
//                Thread.sleep(2000)
//            }
            println("cmd.text: " + cmd.text)
            enterText(cmd.text)
        } else if (cmd.cmd == "text2") {
            println("cmd.text1: " + cmd.text)
            setText(cmd.text)
        } else if (cmd.cmd == "action") {
            performAction(cmd.id)
        }
        index++
        if (cmd.delay < 400) {
            Thread.sleep(cmd.delay.toLong())
            cmdProcess()
        } else {
            //wait state changed
            isUseState = true
        }
    }


    private fun findChildById(id: String) {
        child = Var.childs.find { it.id == id }
    }

    private fun findChildByText(text: String) {
        child = Var.childs.find { it.text == text }
    }

    private fun getChild() {
        nodeFucus = null
        Var.childs.clear()
       val nodeInfo = rootInActiveWindow
        if (nodeInfo == null) {
            println("nodeInfo null: " + Var.childs.size.toString())
            return
        }
        //isChild0 = false
        getChildId(nodeInfo!!)
    }

    private fun getChildId(info: AccessibilityNodeInfo) {
        val i = info.childCount
        for (p in 0 until i) {
            val n = info.getChild(p)
            if (n != null) {
                val id = n.viewIdResourceName

                if (n.text != null) {
                    if (id == idFucus) {
//                        println("idFucus")
                        nodeFucus = n
                        idFucus = ""
                    }
                    val text = n.text.toString()
                    val rect = Rect()
                    n.getBoundsInScreen(rect)
//                    println(viewIdResourceName + " , " + text + " , " + rect.centerX())
                    try {
                        val child = ChildModel(id, text, rect.centerX(), rect.centerY())
                        if (isChildPrint) println(child)
                        Var.childs.add(child)
                    } catch (e: Exception) {
                    }
                }
                getChildId(n)
            }
        }
    }

    private fun setText(text: String) {
        var arguments = Bundle()
        arguments.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text)
        println(nodeFucus?.isEditable)
        nodeFucus?.performAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SET_TEXT.id, arguments)
    }

    private fun enterText(newText: String) {
//        Thread.sleep(500)
        val nodeRoot = rootInActiveWindow
        if (nodeRoot != null) {
//            println("nodeRoot != null")
            val nodeFocused: AccessibilityNodeInfo? = findFocusedField(nodeRoot)
            if (nodeFocused != null) {
                println("nodeFocused != null")
//               var newText = ""
//                val selectionStart = nodeFocused.textSelectionStart
//                val selectionEnd = nodeFocused.textSelectionEnd
//                var typeInMiddle = false
//                if (selectionStart > -1 && selectionStart < newText.length) {
//                    newText = newText.substring(0, selectionStart) + text + newText.substring(selectionEnd)
//                    typeInMiddle = true
//                } else {
//                    newText += text
//                }
                println(newText)
                var arguments = Bundle()
                arguments.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, newText)
                nodeFocused.performAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SET_TEXT.id, arguments)

//                if (typeInMiddle) {
//                    arguments = Bundle()
//                    arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, selectionStart + text.length)
//                    arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, selectionStart + text.length)
//                    nodeFocused.performAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SET_SELECTION.id, arguments)
//                }
            }
        }
    }

    private fun findFocusedField(node: AccessibilityNodeInfo): AccessibilityNodeInfo? {
//        println("${node.isEditable},${node.isFocused}")
        if (node.isEditable && node.isFocused) {
            return node
        }
        for (i in 0 until node.childCount) {
            val nodeChild = node.getChild(i)
            val nodeFocused = findFocusedField(nodeChild)
            if (nodeFocused != null) {
                return nodeFocused
            }
        }
        return null
    }

//    private fun getExistingText(node: AccessibilityNodeInfo): CharSequence? {
//        // node.getText() returns a hint for text fields (terrible!)
//        // Here's a workaround against this
//        var hintText: CharSequence? = null
//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
//            hintText = node.hintText
//        }
//        var existingText = node.text
//        if (hintText != null && existingText == hintText) {
//            existingText = null
//        }
//        return existingText
//    }

    private fun tap(x: Float, y: Float, duration: Long) {
//        println("$x , $y , $duration")
        val gestureBuilder = GestureDescription.Builder()
        val clickPath = Path()
        clickPath.moveTo(x, y)
        val clickStroke = StrokeDescription(clickPath, 0, duration)
        gestureBuilder.addStroke(clickStroke)
        val result = dispatchGesture(gestureBuilder.build(), null, null)
        println("tap, result= " + result)
    }

    private fun swipe(x1: Float, y1: Float, x2: Float, y2: Float, duration: Long) {
        val gestureBuilder = GestureDescription.Builder()
        val clickPath = Path()
        clickPath.moveTo(x1, y1)
        clickPath.lineTo(x2, y2)
        val clickStroke = StrokeDescription(clickPath, 0, duration)
        gestureBuilder.addStroke(clickStroke)
        val result = dispatchGesture(gestureBuilder.build(), null, null)
        println("swipe, result= " + result)
    }

    private fun performAction(cmd: String) {
        var intAction = GLOBAL_ACTION_HOME
        if (cmd == "BACK") intAction = GLOBAL_ACTION_BACK
        else if (cmd == "RECENT") intAction = GLOBAL_ACTION_RECENTS
        else if (cmd == "SCREENSHOT") intAction = GLOBAL_ACTION_TAKE_SCREENSHOT
        else if (cmd == "NOTIFICATION") intAction = GLOBAL_ACTION_NOTIFICATIONS
        else if (cmd == "POWER") intAction = GLOBAL_ACTION_POWER_DIALOG
        performGlobalAction(intAction)
    }

//    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
//        val intType = event?.eventType
//        println("intType: " + intType.toString())
//        if (intType == 32) {
//            println("32 = TYPE_WINDOW_STATE_CHANGED")
//            Var.isStateChanged = true
//            nodeInfo = rootInActiveWindow
//
//        }
//        val packetName = event?.packageName.toString()
//        val packageManager = getPackageManager()


    /*
//        println(" onServiceConnected()")
    val packetName = event?.packageName.toString()
    val packageManager = getPackageManager()
    try {
        val appInfo = packageManager.getApplicationInfo(packetName,0)
        val appLabel = packageManager.getApplicationLabel(appInfo)
//            val componentName =  ComponentName()
//            val appLabel2 = packageManager.getActivityInfo()
        val className = appInfo.className
        val intType = event?.eventType
        println(intType)
//            if (intType  == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) println("TYPE_WINDOW_STATE_CHANGED")
        println("app name: " + appLabel +"_,_" + className )

    } catch (e:PackageManager.NameNotFoundException) {
        //println(e.message)
    }
    */
    //}

//    override fun onServiceConnected() {
//        super.onServiceConnected()
//        val info = AccessibilityServiceInfo()
//        info.eventTypes =  AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED //AccessibilityEvent.TYPE_VIEW_CLICKED or
//        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC
//        info.notificationTimeout = 100
//        setServiceInfo(info)
////        println(" onServiceConnected()")
//    }

    override fun onInterrupt() {

    }

    fun sendTestData() {
        val retrofit = Retrofit.Builder()
            .baseUrl(Var.BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val api = retrofit.create(ApiService::class.java)

        val call = api.testSendData("Bearer " + Var.accessToken)
        call.enqueue(object : Callback<ApiResponse> {
            override fun onResponse(call: Call<ApiResponse>, res: Response<ApiResponse>) {
                println(res.body()?.data)
                Toast.makeText(applicationContext, res.body()?.data.toString(), Toast.LENGTH_SHORT).show()
            }

            override fun onFailure(call: Call<ApiResponse>, t: Throwable) {
                println("onFailure")
            }
        })

    }

    override fun onDestroy() {
        super.onDestroy()
        println("Access service stop")
    }
/*
    @RequiresApi(Build.VERSION_CODES.O)
    fun startNotification() {
        var flag = 0
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) flag = PendingIntent.FLAG_MUTABLE
        val pendingIntent = Intent(this, MainActivity::class.java).let { notificationIntent ->
            PendingIntent.getActivity(this, 0, notificationIntent, flag)
        }
        val notification = NotificationCompat.Builder(this, createNotificationChannel())
            .setContentTitle(resources.getString(R.string.app_name))
            //.setContentText("")
            .setSmallIcon(R.drawable.ic_notify)
            //.setTicker("Download started")
            .setContentIntent(pendingIntent)
            .build()
        startForeground(NOTIFICATION_ID, notification)
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun createNotificationChannel(): String {
        val channelId = getString(R.string.default_notification_channel_id)
        val channelName = "TFB"
        val chan = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_NONE)
        chan.lockscreenVisibility = Notification.VISIBILITY_PRIVATE
        val service = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        service.createNotificationChannel(chan)
        return channelId
    }
    */
}